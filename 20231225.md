

# Mastodon改造の流れをざっくり説明する。
この記事はFediverse Advent Calendar 2023 第三会場 25日目の記事です。

今回はDislike機能(よくないね)の実装を目標に、Favourite機能(いいね)の動作をかなりざっくりと説明していきたいと思います。
1時間ぐらいで書いたので誤字脱字たぶんある。

## 1.テーブルとモデルを見る
テーブル構造は```db/schema.rb```を確認します。
favouritesは455行目付近に記述があります。
```ruby
  create_table "favourites", force: :cascade do |t|
    t.datetime "created_at", precision: nil, null: false
    t.datetime "updated_at", precision: nil, null: false
    t.bigint "account_id", null: false
    t.bigint "status_id", null: false
    t.index ["account_id", "id"], name: 
"index_favourites_on_account_id_and_id"
    t.index ["account_id", "status_id"], name: 
"index_favourites_on_account_id_and_status_id", unique: true
    t.index ["status_id"], name: "index_favourites_on_status_id"
  end
```

favoutiresテーブルはこのような構造となっていることがわかります。

名称|id|status_id|account_id|created_at|updated_at
-|-|-|-|-|-
型|bigint|bigint|bigint|datetime|datetime
備考|プライマリキー|Likeされた投稿|Likeしたアカウント|Likeした日時||

また、インデックスとしてaccount_id、status_idと関連付けされています。


続いて、モデルの中身を知るために```app/models/favourite.rb```を確認します。
```ruby
class Favourite < ApplicationRecord
  include Paginable

  update_index('statuses', :status)

  belongs_to :account, inverse_of: :favourites
  belongs_to :status,  inverse_of: :favourites

  has_one :notification, as: :activity, dependent: :destroy

  validates :status_id, uniqueness: { scope: :account_id }

  before_validation do
    self.status = status.reblog if status&.reblog?
  end

  after_create :increment_cache_counters
  after_destroy :decrement_cache_counters
  after_destroy :invalidate_cleanup_info

  private
　以下省略
```
今回は必要最低限の説明に留めますが
belongs_toでstatusモデル、accountモデルとの関連付けをしていますのでfavourite.statusでLikeされた投稿を、favourite.accountでLikeしたアカウントを参照することができます。  

statusモデルである```app/models/status.rb```を見てみると逆の記述があります。
```ruby
  has_many :favourites, inverse_of: :status, dependent: :destroy
```
なお、dependentがdestroyのため、statusを削除するとstatusに対するfavouriteも削除されます。

accountモデルは複数のファイルに別れており、同様の記述が```app/models/concerns/account_associations.rb```にあります。
```ruby
has_many :favourites, inverse_of: :account, dependent: :destroy
```
こちらもdestroyであるため、favouriteしたaccountが削除されるとfavouriteも削除されます

また、```app/models/concerns/account_interactions.rb```には便利なメソッドがあります。これはaccountがstatusに対して既にlikeしたかどうかを判定するものなっております。
```ruby
  def favourited?(status)
    status.proper.favourites.where(account: self).exists?
  end
```

もしLike(Favourite)のようなアクティビティであるDislikeを新規で実装する場合は```rails 
g model 
Dislike```でマイグレーションとモデルを生成し、次のとおり記載します。  

>db/migrate/YYMMDDTTTTTT_create_users_create_dislikes.rb
(新規生成される。YYMMDDTTTTTTはマイグレーションが生成された日時です)

```ruby
  create_table “dislikes", force: :cascade do |t|
    t.datetime "created_at", precision: nil, null: false
    t.datetime "updated_at", precision: nil, null: false
    t.bigint "account_id", null: false
    t.bigint "status_id", null: false
    t.index ["account_id", "id"], name: 
"index_dislikes_on_account_id_and_id"
    t.index ["account_id", "status_id"], name: 
"index_dislikes_on_account_id_and_status_id", unique: true
    t.index ["status_id"], name: "index_dislikes_on_status_id"
  end
```

> app/models/dislike.rb
(新規生成される。下記は最低限の内容です。)

```ruby
class Dislike < ApplicationRecord
  include Paginable

  belongs_to :account, inverse_of: :dislikes
  belongs_to :status,  inverse_of: :dislikes

  before_validation do
    self.status = status.reblog if status&.reblog?
  end

end
```

>app/models/status.rb
(追記する。favouritesの下行あたりに)
```ruby
  has_many :dislikes, inverse_of: :status, dependent: :destroy
```

>app/models/concerns/account_associations.rb
(追記する。favouritesの下行あたりに)
```ruby
has_many :dislikes, inverse_of: :account, dependent: :destroy
```
>app/models/concerns/account_interactions.rb
(追記する。favourited?の下行あたりに)
```ruby
  def disliked?(status)
    status.proper.dislikes.where(account: self).exists?
  end
```


## 2.APIを見る
クライアントアプリからなんらかの操作をするためにAPIというものがあります。これがないと新規作成、削除などの操作できません。

ここでもFavouriteのAPI実装について見ることとしましょう。
Mastodon公式ドキュメントを読むと、Favouriteの操作に関するAPIは次の２つがあります。  
```POST /api/v1/statuses/:id/favourite```
```POST /api/v1/statuses/:id/unfavourite```

まずは```config/routes/api.rb```を確認します。
favourites操作は19行目付近に記述があります。
```ruby
        resource :favourite, only: :create
        post :unfavourite, to: 'favourites#destroy'
```

これは/api/v1/statuses/:id/favouriteがFavouritesControllerのcreateメソッドに、/api/v1/statuses/:id/unfavouriteがFavouritesControllerのdestroyメソッドに割り振られていることがわかります。

次にこれらのAPIのコントローラーである```app/controllers/api/v1/statuses/favourites_controller.rb```を見てみましょう。
```ruby
class Api::V1::Statuses::FavouritesController < Api::BaseController
  include Authorization

  before_action -> { doorkeeper_authorize! :write, :'write:favourites' }
  before_action :require_user!
  before_action :set_status, only: [:create]

  def create
    FavouriteService.new.call(current_account, @status)
    render json: @status, serializer: REST::StatusSerializer
  end

  def destroy
    fav = current_account.favourites.find_by(status_id: 
params[:status_id])

    if fav
      @status = fav.status
      count = [@status.favourites_count - 1, 0].max
      UnfavouriteWorker.perform_async(current_account.id, @status.id)
    else
      @status = Status.find(params[:status_id])
      count = @status.favourites_count
      authorize @status, :show?
    end

    relationships = StatusRelationshipsPresenter.new([@status], 
current_account.id, favourites_map: { @status.id => false }, 
attributes_map: { @status.id => { favourites_count: count } })
    render json: @status, serializer: REST::StatusSerializer, 
relationships: relationships
  rescue Mastodon::NotPermittedError
    not_found
  end

  private

  def set_status
    @status = Status.find(params[:status_id])
    authorize @status, :show?
  rescue Mastodon::NotPermittedError
    not_found
  end
end
```

Favouriteの新規作成の流れを見ていきましょう。  
```before_action: set_status```がありますのでcreateメソッドよりも前にset_statusが呼び出されます。これはstatus_idを元にデータベースからstatusの情報を探してくるものです。  
次にcreateメソッド内をみると```FavouriteService.new.call(current_account, @status)```とあります。これはFavouriteの処理をサービスとしてまとめたものです。中身は```app/services/favourite_service.rb```にあります。

FavouriteServiceを見ると次のとおりです。(長い)
```ruby
class FavouriteService < BaseService
  include Authorization
  include Payloadable

  def call(account, status)
    authorize_with account, status, :favourite?

    favourite = Favourite.find_by(account: account, status: status)

    return favourite unless favourite.nil?

    favourite = Favourite.create!(account: account, status: status)

    Trends.statuses.register(status)

    create_notification(favourite)
    bump_potential_friendship(account, status)

    favourite
  end

  private

  def create_notification(favourite)
    status = favourite.status

    if status.account.local?
      LocalNotificationWorker.perform_async(status.account_id, 
favourite.id, 'Favourite', 'favourite')
    elsif status.account.activitypub?
      ActivityPub::DeliveryWorker.perform_async(build_json(favourite), 
favourite.account_id, status.account.inbox_url)
    end
  end

  def bump_potential_friendship(account, status)
    ActivityTracker.increment('activity:interactions')
    return if account.following?(status.account_id)

    PotentialFriendshipTracker.record(account.id, status.account_id, 
:favourite)
  end

  def build_json(favourite)
    Oj.dump(serialize_payload(favourite, ActivityPub::LikeSerializer))
  end
end
```

まずは```favourite = Favourite.find_by(account: account, status: 
status)```で既にFavouriteがあるかどうかを検索しています。ここで既にaccountがstatusにFavouriteしているとfavouriteはnilではないため```return 
favourite unless 
favourite.nil?```により検索結果より得たFavouriteオブジェクトがそのまま返されます。
次に```return favourite unless favourite.nil?```以降を見ていきましょう。これ以降はaccountがstatusにまだFavouriteしていない場合の処理です。
```favourite = Favourite.create!(account: account, status: status)```はFavouriteモデルからFavouriteオブジェクト(実態)を作り出しております。
この時点でデータベースに新たなFavourite作成されます。最後にendの前に```favourite```とあります。これはFavouriteServiceの呼び出し元であるFavouritesControllerに生成したFavouriteオブジェクトを返しております。
なお、連合先の投稿の場合はActivityPub::DeliveryWorkerによって配送されます。ActivityPub関係の処理については後述します。

FavouritesControllerに返されたFavouriteオブジェクトはcreateメソッドでは使用されていません。
代わりに```render json: @status, serializer: REST::StatusSerializer```によってstatusをStatusSerializerで整形してjson形式でクライアントにレスポンスしています。

削除であるdestroyメソッドについてもだいたいの流れは同じですが、削除は時間がかかる処理であるため```UnfavouriteWorker.perform_async(current_account.id, @status.id)```により、ワーカーという仕組みを通じてサービスを呼び出しております。
なお、Worker処理は非同期であるため必要な返り値がすぐに得られません。そのためレスポンス用に細工が必要です。
favourite削除の場合は現在のstatus.favourite_countより1を減算してレスポンスしています。

Dislikeを実装する場合もほとんど同じような記載になります。ほとんどコピペで可能。

>config/routes/api.rb
```ruby
        resource :dislike, only: :create
        post :undislike, to: 'dislikes#destroy'
```

>app/controllers/api/v1/statuses/dislikes_controller.rb
新規作成する。rails g controllerで生成しても良いですがオプションを指定しないといらないものまで生成されます
```ruby
class Api::V1::Statuses::DislikesController < Api::BaseController
  include Authorization

  before_action -> { doorkeeper_authorize! :write, :'write:favourites' }
  before_action :require_user!
  before_action :set_status, only: [:create]

  def create
    DislikeService.new.call(current_account, @status)
    render json: @status, serializer: REST::StatusSerializer
  end

  def destroy
    dislike = current_account.dislikes.find_by(status_id: 
params[:status_id])

    if dislike
      @status = fav.status
    else
      @status = Status.find(params[:status_id])
      authorize @status, :show?
    end
    render json: @status, serializer: REST::StatusSerializer
  rescue Mastodon::NotPermittedError
    not_found
  end

  private

  def set_status
    @status = Status.find(params[:status_id])
    authorize @status, :show?
  rescue Mastodon::NotPermittedError
    not_found
  end
end
```
destroyについては後のワーカー説明で実装しますので今はUndislikeWorkerを省略します。
doorkeeper_authorizeはfavouriteと同じ権限としました。

>app/services/dislike_service.rb
```ruby
class DislikeService < BaseService
  include Authorization
  include Payloadable

  def call(account, status)
    authorize_with account, status, :favourite?

    dislike = Dislike.find_by(account: account, status: status)

    return dislike unless dislike.nil?

    dislike = Dislike.create!(account: account, status: status)

    dislike
  end
end
```
通知処理、トレンド処理やActivityPub処理について今は省略します。
authorize_withについてはfavouruteと同じ権限でできるようにしました。

## 3.ワーカーを見る
Mastodonのようなアプリケーションではユーザーに見える処理を早急に処理し、時間のかかる処理や繰り返しの処理はレスポンスに遅延を発生させないように非同期で処理する必要があります。
そのためにワーカーという仕組みがあります。これはSidekiqというものでバックグラウンド処理しているものです。
先ほど説明を省いたUnfavouriteWorkerを例に説明します。


時間切れです。近日中に書きます。アドカレネタとはなんだったのか

## 4.シリアライザー、バリデーターを見る
時間切れです。また今度書きます。たぶん

## 5.ActivityPub処理を見る
時間切れです。また今度書きます。おそらく

## 6.フロントエンドを見る(API叩く編)
時間切れです。また今度書きます。きっと

## 7.フロントエンドを見る(部品・CSS編)
時間切れです。また今度書きます。もしかしたら

## 8.その他関連処理(通知など)を見る
時間切れです。また今度書きます。いつか

## 9.テストを見てみる
時間切れです。また今度書きます。気が向いたら

## さいごに
以上が、最低限の説明となります。気力があればこの文章は更新します。

Mastodonを改変してあらたなアクティビティをつくる場合は、まだまだバリデーター、シリアライザー、フロントエンド関連などさまざまなものをいじる必要がありますが今回はここまでとします。

参考として、DislikeではありませんがLike(Favourite)と似たようなアクティビティであるリアクション(EmojiReact)の追加についての変更箇所を貼っておきます。ほとんどDislikeと同じです。(リアクション機能も素人ざっくり実装です)
https://github.com/marunai/mastodon/commit/c35520767f47f30732e9c3dbc00ff23ffc825805#diff-cec0186b2c799e5e23826310a664e009697fbb40ac87f20e0199be4948fac09d
